  终于TM弄懂了
  单源最短路径问题Dijkstra算法，就像画画一样从粗到细，就像最小生成树那样生成最小路径，就像BFS那样分离黑白。看过好多例子还是稀里糊涂的，终于TM弄懂了
  
  
  
  普通图用0/1表示通断，还可用数值表示边长，但dijkstra图更进一步，蕴含了各点的路径关系。
  策略：将顶点分为已知最短路径顶点集合S和未知顶点集合Q，一开始S=空 Q=G.v()，循环把Q中距离s最短的顶点u加入S就生成了最短路径，找到这样的顶点u
并改写最短距离叫松弛,循环条件是Q为空时结束。
  具体做法：book[i]记录顶点在S还是Q中（为1在S 为0在Q），dis[i]记录距离估值（能直接到达的为e[s][i],否则∞）。寻找点u(dis[u]最小)加入集合S，
考察所有以u为起点的边，依次松弛。
  松弛：存在一条从u到v的边，那么可以通过将边u->v添加到尾部来拓展一条从s到v的路径，这条路径的长度是dis[u]+e[u][v]。如果这个值比目前已知的dis[v]
的值要小，我们可以用新值来替代当前dis[v]中的值。
  重复松弛，直到Q为空，dis数组就是源点到所有顶点的路径。
  
  算法复杂度是O（n2），能优化到m*logn
  
  初始化
  分离
  松弛

