C中的字符串有三种表示方法:
1.双引号字符串常量，“dwadwa”;            //返回的值是地址
2.字符数组，以'\0'结尾。 char s[20];     //返回的值是地址
3.string类型。 string s;                //返回的值是string类型，不是地址

字符串数组与指针的关系
char s[100][100]; 存储的是字符数组，实际内容是{'a'	'b'	'c'	'c'	'\0','w'	'a'	'q'	'w'	'\0','w'	'q'	'q'	'd'	'\0'}这样，查看siezof(s[0])是100。
s[0]是一个字符数组，并不能把字符串标识符所代表的地址赋值给字符数组（只可以在定义的时候初始化，比如char s[100][100]={"dwad","dwqdq","aaaa"}但之后就
不能赋值了,因为类型不同，会报错）编译器所说的const char*其实就是地址的意思，不等于二维数组的char*类型。因为字符串常量的直接值是一个指针，而不是这些字
符本身，例如：char a[5];a[0] = "a";就是错误的，报错结果：invalid conversion from 'const char*' to 'char'。char s[100]="love"没问题，因为左右都
是地址。

char *s[100];
而char *s[100]是指针数组，存储的是地址，实际内容是{0076D24C 0076D24C 0076D24C}这样，查看sizeof(s[0],s[1],s[2],s[3])都一直是4。而字符串的返回值呢，
不管是双引号的字符串常量"wdqdq"，还是字符数组char t[20]，返回值都是一个地址(string类型返回值不是地址，比如string t="212",t就是string类型，而非地址)。
所以char *s[100]这样的指针数组才能接收字符串地址。实际的字符串保存在其他地方,char [100][100]把字符串保存在自己内部。

char **s:不能定义二位数组，因为指针指向的位置未知，不能开辟内存空间。
