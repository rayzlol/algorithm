有三种表示方法:
1.双引号字符串常量，“dwadwa”;            //返回的值是地址
2.字符数组，以'\0'结尾。 char s[20];     //返回的值是地址
3.string类型。 string s;                //返回的值是string类型，不是地址

//之间关系
char *s不可用字符串常量初始化，但const char *s可以
二维数组char *s[100]是指针数组，存放的是指针，不可用字符串常量初始化。
const char *s也是指针数组，存放的是指针，但是可以用字符串常量初始化。


//与const的关系






//c字符串 c++字符串类型 库函数的关系


//字符串数组

//整形 浮点型 类型转换，与字符的关系

//输入输出格式化
C风格字符串和c++ string类型字符串的区别
很多c的库函数只适用c风格的字符串，同样c++也是如此
比如类型转换函数atoi atof都是c库函数，参数要是c风格字符串char s[20]这样
c++的转换函数to_string()，就是转为c++的string类型，是你不可混用的


字符串数组与指针的关系
char s[100][100]; 存储的是字符数组，实际内容是{'a''b''c''c''\0','w''a''q''w''\0','w''q''q''d''\0'}这样，查看siezof(s[0])是100。
s[0]是一个字符数组，并不能把字符串标识符所代表的地址赋值给字符数组（只可以在定义的时候初始化，比如char s[100][100]={"dwad","dwqdq","aaaa"}但之后就
不能赋值了,因为类型不同，会报错）编译器所说的const char*其实就是地址的意思，不等于二维数组的char*类型。因为字符串常量的直接值是一个指针，而不是这些字
符本身，例如：char a[5];a[0] = "a";就是错误的，报错结果：invalid conversion from 'const char*' to 'char'。char s[100]="love"没问题，因为左右都
是地址。

char *s[100];
而char *s[100]是指针数组，存储的是地址，实际内容是{0076D24C 0076D24C 0076D24C}这样，查看sizeof(s[0],s[1],s[2],s[3])都一直是4。而字符串的返回值呢，
不管是双引号的字符串常量"wdqdq"，还是字符数组char t[20]，返回值都是一个地址(string类型返回值不是地址，比如string t="212",t就是string类型，而非地址)。
所以char *s[100]这样的指针数组才能接收字符串地址。实际的字符串保存在其他地方,char [100][100]把字符串保存在自己内部，char *s[100]是不能用
{"wdq","wdq","d21"}初始化的。

但很奇怪的是const char *, const char *s[100]就可以用字符串常量初始化和赋值

char **s:不能定义二位数组，因为指针指向的位置未知，不能开辟内存空间。
